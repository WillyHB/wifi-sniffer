#include <linux/module.h>
#include <linux/byteorder/generic.h>
#include <linux/ip.h>
#include "linux/printk.h"
#include "linux/rtnetlink.h"
#include <linux/kernel.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/tcp.h>
#include <net/ieee80211_radiotap.h>
#include <linux/ieee80211.h>
#include <net/cfg80211.h>
#include "sniffer.h"

// Good To Remember:
// STA: Station which participates in an 802.11 network (laptop, phone, even AP)
// BSS: Group of STAs which can talk to each other under a single AP
// BSSID: The unique MAC Address which identifies a BSS (Usually the APs MAC address)
// IBSS: Independent BSS (So no AP, only STAs talking to each other)
// DS: Distribution System - Infrastructure which connects APs (Ethernet or other)

struct net_device *mydev;
struct net_device *real_dev;

void mywifi_dev_init(struct net_device *dev) {
	if (dev == NULL) return;

	dev->netdev_ops = &sniffer_ops;

	ether_setup(dev);
	eth_random_addr((u8*)dev->dev_addr);
	dev->mtu = 1500; // Max Transition Unit (largest payload)
    dev->tx_queue_len = 100;
    dev->flags = IFF_NOARP | IFF_BROADCAST | IFF_MULTICAST;
	dev->addr_assign_type = NET_ADDR_RANDOM;
}

int sniffer_init(void) {
	printk(KERN_INFO "Sniffer loaded!\n");

	mydev = alloc_netdev(
		sizeof(struct SNIFFER_PRIV), 
		"mywifi%d", 
		NET_NAME_ENUM, 
		mywifi_dev_init);

	if (!mydev) {
		printk(KERN_ERR "Failed to allocate net_device\n");
		return ENOMEM;
	}

	if(register_netdev(mydev)) {
      	printk(KERN_ERR "Failed to register net device\n");
        free_netdev(mydev);
		return -1;
	}

	real_dev = dev_get_by_name(&init_net, "mon0");

	if (!real_dev) {
		printk(KERN_ERR "Net Device %s not found", "mon0");
		unregister_netdevice(mydev);
		free_netdev(mydev);
		return -1;
	}

	rtnl_lock();
	int ret = netdev_rx_handler_register(real_dev, mywifi_rx_handler, mydev);
	rtnl_unlock();

	if (ret) {
		printk(KERN_ERR "Failed to register RX handler\n");
		dev_put(real_dev);
		unregister_netdev(mydev);
		free_netdev(mydev);
		return ret;
	}

    printk(KERN_INFO "Netdevice registered successfully\n");
	return 0;
}

struct radiotap_info get_radiotap_info(struct ieee80211_radiotap_header *rt_hdr, u16 rt_len) {
	struct ieee80211_radiotap_iterator iter = {0};
	int ret = ieee80211_radiotap_iterator_init(&iter , rt_hdr , rt_len , NULL);

	struct radiotap_info info = {0};

	while (!ret) {
		ret = ieee80211_radiotap_iterator_next(&iter);
		if (ret) continue;

		switch (iter.this_arg_index) {
			case IEEE80211_RADIOTAP_DB_ANTSIGNAL:
				info.rssi = (int8_t)(*iter.this_arg);
				break;
			case IEEE80211_RADIOTAP_CHANNEL:
				info.channel_freq = get_unaligned_le16(iter.this_arg);
				info.channel_flags = get_unaligned_le16(iter.this_arg + 2);
				break;
		}
	}

	return info;
}

rx_handler_result_t mywifi_rx_handler(struct sk_buff **pskb) {
	struct sk_buff *skb = *pskb;

	struct wifi_frame_info info = {0};

	struct ieee80211_radiotap_header *rt_hdr = (struct ieee80211_radiotap_header*)skb->data;
	u16 rt_len = le16_to_cpu(rt_hdr->it_len);
	if (skb->len < rt_len)
		return RX_HANDLER_PASS;

	struct radiotap_info rt_info = get_radiotap_info(rt_hdr, rt_len);
	info.rt_info = rt_info;

	struct ieee80211_hdr *hdr = (struct ieee80211_hdr*)(skb->data+rt_len);
	u16 fc = le16_to_cpu(hdr->frame_control);
	u8 type = (fc & IEEE80211_FCTL_FTYPE) >> 2;
	u8 subtype = (fc & IEEE80211_FCTL_STYPE) >> 4;

	u8 tods = (fc & IEEE80211_FCTL_TODS) >> 8;
	u8 fromds = (fc & IEEE80211_FCTL_FROMDS) >> 9;

	if (tods == 0 && fromds == 0) { // Not going or coming from DS, so from a non AP STA

	} else if (tods == 1 && fromds == 0) { // Data frame sent to DS by an STA

	} else if (tods == 0 && fromds == 1) {

	} else if (tods == 1 && fromds == 1) {

	}

	u16 hdr_len = ieee80211_hdrlen(hdr->frame_control);
	printk_ratelimited(KERN_INFO "802.11: type=%d subtype=%d "
                 "A1 %pM A2 %pM A3 %pM\n",
                 type, subtype,
                 hdr->addr1, hdr->addr2, hdr->addr3);

	uint8_t *payload = skb->data+rt_len+hdr_len;

	//printk_ratelimited("DEST_MAC:%pM (%pI4) | SRC_MAC:%pM (%pI4)", eth->h_dest, &ip->daddr, eth->h_source, &ip->saddr);
	return RX_HANDLER_PASS;
}

void sniffer_clean(void) {
	if (real_dev) {
		rtnl_lock();
		netdev_rx_handler_unregister(real_dev);
		rtnl_unlock();
		dev_put(real_dev);
	}

	if (mydev) {
		unregister_netdev(mydev);
		free_netdev(mydev);
	}
    printk(KERN_INFO "Sniffer unloaded\n");
}

int mywifi_open(struct net_device *dev) {
	printk(KERN_INFO "mywifi: device opened\n");
	return 0;
}
int mywifi_close(struct net_device *dev) {
	printk(KERN_INFO "mywifi: device closed\n");
	return 0;
}

netdev_tx_t mywifi_xmit(struct sk_buff *skb, struct net_device *dev) {
	dev_kfree_skb(skb);
	return NETDEV_TX_OK;
}

module_init(sniffer_init);
module_exit(sniffer_clean);


MODULE_AUTHOR("William Hansen-Baird");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("A small project experimenting with WiFi packet sniffing :)");
